using Nebula.Serialization;
using Nebula.Serialization.Serializers;

namespace Nebula {
    /// <summary>
    /// This provides a common interface for NetNode, NetNode2D, and NetNode3D.
    /// This is necessary because they don't share an inheritance chain.
    /// For example, NetNode2D inherits from Node2D, while NetNode ineherits from Node.
    /// NetNode2D cannot inherit from NetNode because it needs Node2D functionality and C# does not support multiple inheritance.
    /// </summary>
    public interface INetNodeBase {
        public NetworkController Network { get; }
        public IStateSerializer[] Serializers { get; }
        public void SetupSerializers();

        /// <summary>
        /// When the node is first spawned, and when players first connect to the world, this method is called to determine the initial interest layers for the node.
        /// </summary>
        /// <returns>The initial interest layers for the node.</returns>
        public long InitializeInterest(NetPeer peer);
        
        /// <summary>
        /// Called once when the world is ready for this node.
        /// </summary>
        public void _WorldReady() { }
        
        /// <summary>
        /// Called each network tick. Override to handle per-tick game logic.
        /// </summary>
        /// <param name="tick">The current network tick</param>
        public void _NetworkProcess(int tick) { }

        /// <summary>
        /// Invokes the property change handler for the given property index.
        /// This method is generated by the source generator for classes with [NetProperty(NotifyOnChange = true)].
        /// Default implementation does nothing - override is generated when properties have NotifyOnChange = true.
        /// </summary>
        /// <param name="propIndex">The index of the property (from GetNetPropertyIndex)</param>
        /// <param name="tick">The network tick when the change occurred</param>
        /// <param name="oldVal">The previous value stored in a PropertyCache</param>
        /// <param name="newVal">The new value stored in a PropertyCache</param>
        public void InvokePropertyChangeHandler(int propIndex, int tick, ref PropertyCache oldVal, ref PropertyCache newVal) { }

        /// <summary>
        /// Sets a network property by its index using the value from a PropertyCache.
        /// This method is generated by the source generator to avoid Godot boundary crossing.
        /// Default implementation does nothing - override is generated for all net properties.
        /// </summary>
        /// <param name="propIndex">The index of the property</param>
        /// <param name="value">The new value stored in a PropertyCache</param>
        public void SetNetPropertyByIndex(int propIndex, ref PropertyCache value) { }

        /// <summary>
        /// Processes interpolation for all interpolated properties.
        /// Called each frame by the serializer on clients.
        /// This method is generated by the source generator for classes with [NetProperty(Interpolate = true)].
        /// </summary>
        /// <param name="delta">Frame delta time in seconds</param>
        public void ProcessInterpolation(float delta) { }

        #region Client-Side Prediction

        /// <summary>
        /// Stores current predicted state for rollback comparison.
        /// Generated implementation stores each [NetProperty(Predicted=true)] property
        /// in a circular buffer indexed by tick.
        /// </summary>
        /// <param name="tick">The tick to associate with this predicted state</param>
        public void StorePredictedState(int tick) { }

        /// <summary>
        /// Stores confirmed server state for reconciliation.
        /// Called when authoritative server state is received.
        /// </summary>
        public void StoreConfirmedState() { }

        /// <summary>
        /// Restores properties to confirmed server state (for rollback).
        /// Called at the start of reconciliation before re-simulating.
        /// </summary>
        public void RestoreToConfirmedState() { }

        /// <summary>
        /// Restores only mispredicted properties to confirmed server state.
        /// Properties that matched within tolerance are left unchanged.
        /// This prevents correct predictions from being overwritten by unrelated mispredictions.
        /// </summary>
        public void RestoreMispredictedToConfirmed() { }

        /// <summary>
        /// Restores properties from the prediction buffer for a given tick.
        /// Used when prediction was correct and we need to continue with predicted values after server state import.
        /// </summary>
        public void RestoreToPredictedState(int tick) { }

        /// <summary>
        /// Compares predicted state at tick with confirmed state.
        /// Returns true if all predicted properties are within tolerance (no misprediction).
        /// Returns false if any property exceeds its tolerance threshold.
        /// </summary>
        /// <param name="tick">The tick whose predicted state to compare</param>
        /// <returns>True if states match within tolerance, false if misprediction detected</returns>
        public bool CompareAllPredictedState(int tick) => true;

        /// <summary>
        /// Smooths render values toward simulation values.
        /// Called every frame in _Process for visual smoothing after corrections.
        /// Only applies to properties with [NetProperty(Predicted=true)].
        /// </summary>
        /// <param name="delta">Frame delta time in seconds</param>
        public void ProcessPredictionSmoothing(float delta) { }

        #endregion
    }

    public interface INetNode<T> : INetNodeBase, INetSerializable<T>, IBsonSerializable<T> where T : Godot.Node { }
}