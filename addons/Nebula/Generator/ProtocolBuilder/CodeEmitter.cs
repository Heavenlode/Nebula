using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace Nebula.Generators
{
    /// <summary>
    /// Generates C# source code for the compiled protocol data.
    /// </summary>
    internal static class CodeEmitter
    {
        public static string Emit(ProtocolData data)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System.Collections.Frozen;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using Nebula.Serialization;");
            sb.AppendLine();
            sb.AppendLine("namespace Nebula.Serialization");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Auto-generated protocol data for network serialization.");
            sb.AppendLine("    /// Use the Protocol helper class for convenient access methods.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class GeneratedProtocol");
            sb.AppendLine("    {");

            // Static methods (serializable types)
            EmitStaticMethods(sb, data);
            
            // Scene maps
            EmitScenesMap(sb, data);
            EmitScenesPack(sb, data);
            
            // Static network node paths
            EmitStaticNetworkNodePathsMap(sb, data);
            EmitStaticNetworkNodePathsPack(sb, data);
            
            // Properties
            EmitPropertiesMap(sb, data);
            EmitPropertiesLookup(sb, data);
            EmitPropertiesByStaticChildId(sb, data);
            
            // Functions
            EmitFunctionsMap(sb, data);
            EmitFunctionsLookup(sb, data);
            
            // Serial type pack
            EmitSerialTypePack(sb, data);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void EmitStaticMethods(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<int, StaticMethodInfo> StaticMethods =");
            sb.AppendLine("            new Dictionary<int, StaticMethodInfo>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.StaticMethods)
            {
                sb.AppendLine($"                [{kvp.Key}] = new StaticMethodInfo((StaticMethodType){kvp.Value.MethodType}, \"{Escape(kvp.Value.TypeFullName)}\"),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitScenesMap(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<byte, string> ScenesMap =");
            sb.AppendLine("            new Dictionary<byte, string>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.ScenesMap)
            {
                sb.AppendLine($"                [{kvp.Key}] = \"{Escape(kvp.Value)}\",");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitScenesPack(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, byte> ScenesPack =");
            sb.AppendLine("            new Dictionary<string, byte>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.ScenesPack)
            {
                sb.AppendLine($"                [\"{Escape(kvp.Key)}\"] = {kvp.Value},");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitStaticNetworkNodePathsMap(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<byte, string>> StaticNetworkNodePathsMap =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<byte, string>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.StaticNetworkNodePathsMap)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<byte, string>");
                sb.AppendLine("                {");
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [{node.Key}] = \"{Escape(node.Value)}\",");
                }
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitStaticNetworkNodePathsPack(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<string, byte>> StaticNetworkNodePathsPack =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<string, byte>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.StaticNetworkNodePathsPack)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<string, byte>");
                sb.AppendLine("                {");
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [\"{Escape(node.Key)}\"] = {node.Value},");
                }
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitPropertiesMap(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<string, FrozenDictionary<string, ProtocolNetProperty>>> PropertiesMap =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<string, FrozenDictionary<string, ProtocolNetProperty>>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.PropertiesMap)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<string, FrozenDictionary<string, ProtocolNetProperty>>");
                sb.AppendLine("                {");
                
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [\"{Escape(node.Key)}\"] = new Dictionary<string, ProtocolNetProperty>");
                    sb.AppendLine("                    {");
                    
                    foreach (var prop in node.Value)
                    {
                        EmitProperty(sb, prop.Key, prop.Value, "                        ");
                    }
                    
                    sb.AppendLine("                    }.ToFrozenDictionary(),");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitPropertiesLookup(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<int, ProtocolNetProperty>> PropertiesLookup =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<int, ProtocolNetProperty>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.PropertiesLookup)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<int, ProtocolNetProperty>");
                sb.AppendLine("                {");
                
                foreach (var prop in scene.Value)
                {
                    EmitPropertyWithIntKey(sb, prop.Key, prop.Value, "                    ");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitPropertiesByStaticChildId(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<byte, FrozenDictionary<string, ProtocolNetProperty>>> PropertiesByStaticChildId =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<byte, FrozenDictionary<string, ProtocolNetProperty>>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.PropertiesByStaticChildId)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<byte, FrozenDictionary<string, ProtocolNetProperty>>");
                sb.AppendLine("                {");
                
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [{node.Key}] = new Dictionary<string, ProtocolNetProperty>");
                    sb.AppendLine("                    {");
                    
                    foreach (var prop in node.Value)
                    {
                        EmitProperty(sb, prop.Key, prop.Value, "                        ");
                    }
                    
                    sb.AppendLine("                    }.ToFrozenDictionary(),");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitProperty(StringBuilder sb, string key, PropertyData prop, string indent)
        {
            var variantType = MapTypeToVariant(prop.TypeFullName, out var subtype);
            var actualSubtype = prop.SubtypeIdentifier ?? subtype ?? "None";
            
            sb.AppendLine($"{indent}[\"{Escape(key)}\"] = new ProtocolNetProperty(");
            sb.AppendLine($"{indent}    \"{Escape(prop.NodePath)}\",");
            sb.AppendLine($"{indent}    \"{Escape(prop.Name)}\",");
            sb.AppendLine($"{indent}    SerialVariantType.{variantType},");
            sb.AppendLine($"{indent}    new SerialMetadata(\"{Escape(actualSubtype)}\"),");
            sb.AppendLine($"{indent}    {prop.Index},");
            sb.AppendLine($"{indent}    {prop.InterestMask}L,");
            sb.AppendLine($"{indent}    (NetLerpMode){prop.LerpMode},");
            sb.AppendLine($"{indent}    {prop.LerpParam.ToString(CultureInfo.InvariantCulture)}f,");
            sb.AppendLine($"{indent}    {prop.ClassIndex},");
            sb.AppendLine($"{indent}    {prop.NotifyOnChange.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.Interpolate.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.InterpolateSpeed.ToString(CultureInfo.InvariantCulture)}f),");
        }

        private static void EmitPropertyWithIntKey(StringBuilder sb, int key, PropertyData prop, string indent)
        {
            var variantType = MapTypeToVariant(prop.TypeFullName, out var subtype);
            var actualSubtype = prop.SubtypeIdentifier ?? subtype ?? "None";
            
            sb.AppendLine($"{indent}[{key}] = new ProtocolNetProperty(");
            sb.AppendLine($"{indent}    \"{Escape(prop.NodePath)}\",");
            sb.AppendLine($"{indent}    \"{Escape(prop.Name)}\",");
            sb.AppendLine($"{indent}    SerialVariantType.{variantType},");
            sb.AppendLine($"{indent}    new SerialMetadata(\"{Escape(actualSubtype)}\"),");
            sb.AppendLine($"{indent}    {prop.Index},");
            sb.AppendLine($"{indent}    {prop.InterestMask}L,");
            sb.AppendLine($"{indent}    (NetLerpMode){prop.LerpMode},");
            sb.AppendLine($"{indent}    {prop.LerpParam.ToString(CultureInfo.InvariantCulture)}f,");
            sb.AppendLine($"{indent}    {prop.ClassIndex},");
            sb.AppendLine($"{indent}    {prop.NotifyOnChange.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.Interpolate.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.InterpolateSpeed.ToString(CultureInfo.InvariantCulture)}f),");
        }

        private static void EmitFunctionsMap(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<string, FrozenDictionary<string, ProtocolNetFunction>>> FunctionsMap =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<string, FrozenDictionary<string, ProtocolNetFunction>>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.FunctionsMap)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<string, FrozenDictionary<string, ProtocolNetFunction>>");
                sb.AppendLine("                {");
                
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [\"{Escape(node.Key)}\"] = new Dictionary<string, ProtocolNetFunction>");
                    sb.AppendLine("                    {");
                    
                    foreach (var func in node.Value)
                    {
                        EmitFunction(sb, func.Key, func.Value, "                        ");
                    }
                    
                    sb.AppendLine("                    }.ToFrozenDictionary(),");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitFunctionsLookup(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<int, ProtocolNetFunction>> FunctionsLookup =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<int, ProtocolNetFunction>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.FunctionsLookup)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<int, ProtocolNetFunction>");
                sb.AppendLine("                {");
                
                foreach (var func in scene.Value)
                {
                    EmitFunctionWithIntKey(sb, func.Key, func.Value, "                    ");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitFunction(StringBuilder sb, string key, FunctionData func, string indent)
        {
            sb.AppendLine($"{indent}[\"{Escape(key)}\"] = new ProtocolNetFunction(");
            sb.AppendLine($"{indent}    \"{Escape(func.NodePath)}\",");
            sb.AppendLine($"{indent}    \"{Escape(func.Name)}\",");
            sb.AppendLine($"{indent}    {func.Index},");
            EmitArgumentsArray(sb, func.Arguments, indent + "    ");
            sb.AppendLine($"{indent}    (NetworkSources){func.Sources}),");
        }

        private static void EmitFunctionWithIntKey(StringBuilder sb, int key, FunctionData func, string indent)
        {
            sb.AppendLine($"{indent}[{key}] = new ProtocolNetFunction(");
            sb.AppendLine($"{indent}    \"{Escape(func.NodePath)}\",");
            sb.AppendLine($"{indent}    \"{Escape(func.Name)}\",");
            sb.AppendLine($"{indent}    {func.Index},");
            EmitArgumentsArray(sb, func.Arguments, indent + "    ");
            sb.AppendLine($"{indent}    (NetworkSources){func.Sources}),");
        }

        private static void EmitArgumentsArray(StringBuilder sb, List<ArgumentData> args, string indent)
        {
            if (args.Count == 0)
            {
                sb.AppendLine($"{indent}System.Array.Empty<NetFunctionArgument>(),");
                return;
            }

            sb.AppendLine($"{indent}new NetFunctionArgument[]");
            sb.AppendLine($"{indent}{{");
            
            foreach (var arg in args)
            {
                var variantType = MapTypeToVariant(arg.TypeFullName, out var subtype);
                var actualSubtype = arg.SubtypeIdentifier ?? subtype ?? "None";
                sb.AppendLine($"{indent}    new NetFunctionArgument(SerialVariantType.{variantType}, new SerialMetadata(\"{Escape(actualSubtype)}\")),");
            }
            
            sb.AppendLine($"{indent}}},");
        }

        private static void EmitSerialTypePack(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, int> SerialTypePack =");
            sb.AppendLine("            new Dictionary<string, int>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.SerialTypePack)
            {
                sb.AppendLine($"                [\"{Escape(kvp.Key)}\"] = {kvp.Value},");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
        }

        private static string MapTypeToVariant(string typeFullName, out string? subtype)
        {
            subtype = null;
            
            return typeFullName switch
            {
                "System.Boolean" or "bool" => "Bool",
                "System.Int16" or "short" => (subtype = "Short", "Int").Item2,
                "System.Int32" or "int" => (subtype = "Int", "Int").Item2,
                "System.Byte" or "byte" => (subtype = "Byte", "Int").Item2,
                "System.Int64" or "long" => "Int",
                "System.UInt64" or "ulong" => (subtype = "ULong", "Int").Item2,
                "System.Single" or "float" => "Float",
                "System.Double" or "double" => "Float",
                "System.String" or "string" => "String",
                "System.Byte[]" or "byte[]" => "PackedByteArray",
                "System.Int64[]" or "long[]" => "PackedInt64Array",
                "Godot.Vector2" => "Vector2",
                "Godot.Vector2I" => "Vector2I",
                "Godot.Vector3" => "Vector3",
                "Godot.Vector3I" => "Vector3I",
                "Godot.Vector4" => "Vector4",
                "Godot.Quaternion" => "Quaternion",
                "Godot.Color" => "Color",
                "Godot.Transform2D" => "Transform2D",
                "Godot.Transform3D" => "Transform3D",
                "Godot.Basis" => "Basis",
                "Godot.Rect2" => "Rect2",
                "Godot.Rect2I" => "Rect2I",
                "Godot.Aabb" => "Aabb",
                "Godot.Plane" => "Plane",
                "Godot.Projection" => "Projection",
                _ when typeFullName.StartsWith("Godot.") => "Object",
                _ when typeFullName.Contains("[]") => "Array",
                _ => "Object" // Custom types default to Object
            };
        }

        private static string Escape(string s)
        {
            return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
        }
    }
}