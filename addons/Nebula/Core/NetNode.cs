using System;
using System.ComponentModel;
using Godot;
using Nebula.Serialization;
using Nebula.Serialization.Serializers;
using MongoDB.Bson;
using System.Threading.Tasks;

namespace Nebula
{
    /**
		<summary>
		<see cref="Node">Node</see>, extended with Nebula networking capabilities. This is the most basic networked object.
		On every network tick, all NetNode nodes in the scene tree automatically have their <see cref="NetProperty">network properties</see> updated with the latest data from the server.
		Then, the special <see cref="_NetworkProcess(int)">NetworkProcess</see> method is called, which indicates that a network Tick has occurred.
		Network properties can only update on the server side.
		For a client to update network properties, they must send client inputs to the server via implementing the <see cref="INetworkInputHandler"/> interface, or network function calls via <see cref="NetFunction"/> attributes.
		The server receives client inputs, can access them via <see cref="NetworkController.GetInput"/>, and handle them accordingly within <see cref="_NetworkProcess(int)">NetworkProcess</see> to mutate state.
		</summary>
	*/
    [Icon("res://addons/Nebula/Core/NetNode.png")]
    public partial class NetNode : Node, INetNode<NetNode>, INotifyPropertyChanged
    {
        public NetworkController Network { get; internal set; }
        public NetNode()
        {
            Network = new NetworkController(this);
        }
        // Cannot have more than 8 serializers
        public IStateSerializer[] Serializers { get; private set; } = [];

        public override void _Notification(int what)
        {
            if (what == NotificationSceneInstantiated)
            {
                Network.Setup();
            }
        }

        public virtual long InitializeInterest(NetPeer peer)
        {
            // By default, the peer has full interest in the node.
            return long.MaxValue;
        }

        public void SetupSerializers()
        {
            var spawnSerializer = new SpawnSerializer(Network);
            var propertySerializer = new NetPropertiesSerializer(Network);
            Serializers = [spawnSerializer, propertySerializer];
        }

        public virtual void _WorldReady() { }
        public virtual void _NetworkProcess(int _tick) { }

        /// <summary>
        /// Processes interpolation for all interpolated properties.
        /// Override is generated by the source generator for classes with [NetProperty(Interpolate = true)].
        /// </summary>
        /// <param name="delta">Frame delta time in seconds</param>
        internal virtual void ProcessInterpolation(float delta) { }

        /// <summary>
        /// Sets a network property by its class-local index.
        /// Override is generated by the source generator for classes with [NetProperty] attributes.
        /// </summary>
        /// <param name="propIndex">The class-local property index</param>
        /// <param name="value">The new value from the network</param>
        internal virtual void SetNetPropertyByIndex(int propIndex, ref PropertyCache value) { }

        /// <summary>
        /// Invokes property change handlers for properties with NotifyOnChange = true.
        /// Override is generated by the source generator.
        /// </summary>
        internal virtual void InvokePropertyChangeHandler(int propIndex, int tick, ref PropertyCache oldVal, ref PropertyCache newVal) { }

        /// <inheritdoc/>
        public override void _Process(double delta)
        {
            base._Process(delta);
            // Process interpolation on clients only
            if (!NetRunner.Instance.IsServer)
            {
                ProcessInterpolation((float)delta);
                foreach (var child in Network.StaticNetworkChildren)
                {
                    child?.NetNode?.ProcessInterpolation((float)delta);
                }
            }
        }

        /// <inheritdoc/>
        public override void _PhysicsProcess(double delta) { }

        public static void NetworkSerialize(WorldRunner currentWorld, NetPeer peer, NetNode obj, NetBuffer buffer)
        {
            if (obj == null)
            {
                NetWriter.WriteByte(buffer, 0);
                return;
            }
            NetId targetNetId;
            byte staticChildId = 0;
            if (obj.Network.IsNetScene())
            {
                targetNetId = obj.Network.NetId;
            }
            else
            {
                if (Protocol.PackNode(obj.Network.NetSceneFilePath, obj.Network.NetParent.RawNode.GetPathTo(obj), out staticChildId))
                {
                    targetNetId = obj.Network.NetParent.NetId;
                }
                else
                {
                    throw new Exception($"Failed to pack node: {obj.Network.NetParent.NetSceneFilePath} cannot find static child {obj.Network.NetParent.RawNode.GetPathTo(obj)}: {obj.GetPath()}");
                }
            }
            var peerNodeId = currentWorld.GetPeerWorldState(peer).Value.WorldToPeerNodeMap[targetNetId];
            NetWriter.WriteByte(buffer, peerNodeId);
            NetWriter.WriteByte(buffer, staticChildId);
        }

        public static NetNode NetworkDeserialize(WorldRunner currentWorld, NetPeer peer, NetBuffer buffer, NetNode existing = null)
        {
            // Note: existing parameter ignored - NetNode deserialization is a lookup, not a create/update
            var networkID = NetReader.ReadByte(buffer);
            if (networkID == 0)
            {
                return null;
            }
            var staticChildId = NetReader.ReadByte(buffer);
            var node = currentWorld.GetNodeFromNetId(networkID)?.RawNode as NetNode;
            if (node == null)
            {
                return null;
            }
            if (staticChildId > 0)
            {
                node = node.GetNodeOrNull(Protocol.UnpackNode(node.SceneFilePath, staticChildId)) as NetNode;
            }
            return node;
        }

        public BsonValue BsonSerialize(NetBsonContext context)
        {
            var doc = new BsonDocument();
            if (Network.IsNetScene())
            {
                var netId = Network.NetId;
                doc["NetId"] = NetId.BsonSerialize(in netId);
            }
            else
            {
                var parentNetId = Network.NetParent.NetId;
                doc["NetId"] = NetId.BsonSerialize(in parentNetId);
                doc["StaticChildPath"] = Network.NetParent.RawNode.GetPathTo(this).ToString();
            }
            return doc;
        }

        public virtual async Task OnBsonDeserialize(NetBsonContext context, BsonDocument doc)
        {
            // Base implementation - no custom logic needed for NetNode
            // Derived classes should override this method
            await Task.CompletedTask;
        }

        public async Task<NetNode> BsonDeserialize(NetBsonContext context, byte[] bson)
        {
            return await BsonDeserialize(context, bson, this);
        }

        public static async Task<NetNode> BsonDeserialize(NetBsonContext context, byte[] bson, NetNode obj)
        {
            var data = BsonTransformer.Instance.DeserializeBsonValue<BsonDocument>(bson);
            if (data.IsBsonNull) return null;
            var doc = data.AsBsonDocument;
            var node = obj ?? new NetNode();

            // NetNode-specific deserialization logic
            node.Network._prepareNetId = NetId.BsonDeserialize(doc["NetId"]);
            if (doc.Contains("StaticChildPath"))
            {
                node.Network._prepareStaticChildPath = doc["StaticChildPath"].AsString;
            }

            // Call the virtual method for custom deserialization logic
            await node.OnBsonDeserialize(context, doc);

            return node;
        }

        public string NodePathFromNetScene()
        {
            if (Network.IsNetScene())
            {
                return GetPathTo(this);
            }

            return Network.NetParent.RawNode.GetPathTo(this);
        }
    }
}
