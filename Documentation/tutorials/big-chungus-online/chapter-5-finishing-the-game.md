# Big Chungus Online - Finishing The Game

This chapter covers:

* Player vs. Player
* Loss conditions
* Game reset

## Player vs. Player

when a player collides with another player, we want to make the bigger one "consume" the smaller one. By also taking some portion of their points, they "grow" by consuming the other player!

We'll put the consumption logic in the `GameScoreManager.cs` script, alongside the pellet consumption logic. We won't belabor the details of this logic since this is a Nebula tutorial rather than a general coding tutorial. Also, this code was shamelessly generated by AI ;)

But, just to break down what you're about to read:

1. For each player
2. Check if its "CollisionRadius" overlaps with any "CollisionRadius" of any other player
3. If so, make the bigger player's score incrase by half of the smaller player's score
4. Finally, despawn all consumed smaller players

```cs

    private void CheckPlayerCollisions()
    {
        List<Player> playersToDespawn = null;
        for (int i = 0; i < Players.Count; i++)
        {
            var player1 = Players[i];
            if (playersToDespawn?.Contains(player1) == true) continue;

            for (int j = i + 1; j < Players.Count; j++)
            {
                var player2 = Players[j];
                if (player1.Network.IsQueuedForDespawn || player2.Network.IsQueuedForDespawn) continue;

                if (playersToDespawn?.Contains(player2) == true) continue;

                var pos1 = player1.GetWorldPosition();
                var pos2 = player2.GetWorldPosition();

                float radius1 = player1.GetCollisionRadius();
                float radius2 = player2.GetCollisionRadius();

                float distanceSquared = (pos1.X - pos2.X) * (pos1.X - pos2.X)
                                      + (pos1.Z - pos2.Z) * (pos1.Z - pos2.Z);
                float combinedRadius = radius1 + radius2;

                if (distanceSquared < combinedRadius)
                {
                    // Collision detected - bigger player eats smaller one
                    Player bigger, smaller;
                    if (player1.Score >= player2.Score)
                    {
                        bigger = player1;
                        smaller = player2;
                    }
                    else
                    {
                        bigger = player2;
                        smaller = player1;
                    }

                    // Add 50% of smaller's score to bigger
                    bigger.Score += smaller.Score / 2;

                    // Queue the smaller player for despawn
                    playersToDespawn ??= new List<Player>();
                    playersToDespawn.Add(smaller);
                }
            }

            // Despawn players that have been eaten
            if (playersToDespawn != null)
            {
                foreach (var player in playersToDespawn)
                {
                    player.Network.Despawn();
                    Players.Remove(player);
                }
            }
        }
    }
```

`player.Network.Despawn()` means that node will be removed from the Server's scene tree, and all clients will be notified of the despawn event so they can also remove it from their respective scene trees.


Our final `GameScoreManager.cs`:

```cs
using Godot;
using Nebula;
using System.Collections.Generic;

public partial class GameScoreManager : NetNode
{
    [Export]
    public PelletSpawner PelletSpawner;
    public List<Player> Players { get; } = new();
    public override void _NetworkProcess(int tick)
    {
        base._NetworkProcess(tick);

        if (Network.IsClient)
        {
            return;
        }

        CheckPelletCollisions();
        CheckPlayerCollisions();
    }

    private void CheckPelletCollisions()
    {
        if (PelletSpawner == null) return;

        var pelletPositions = PelletSpawner.PelletPositions;

        foreach (var player in Players)
        {
            var playerPos = player.GetWorldPosition();
            float collisionRadius = player.GetCollisionRadius();

            for (int i = 0; i < pelletPositions.Length; i++)
            {
                var pelletPos = pelletPositions[i];
                float distanceSquared = (playerPos.X - pelletPos.X) * (playerPos.X - pelletPos.X)
                                      + (playerPos.Z - pelletPos.Z) * (playerPos.Z - pelletPos.Z);

                if (distanceSquared < collisionRadius)
                {
                    player.Score++;
                    PelletSpawner.RespawnPellet(i);
                }
            }
        }
    }

    private void CheckPlayerCollisions()
    {
        List<Player> playersToDespawn = null;

        for (int i = 0; i < Players.Count; i++)
        {
            var player1 = Players[i];
            if (playersToDespawn?.Contains(player1) == true) continue;

            for (int j = i + 1; j < Players.Count; j++)
            {
                var player2 = Players[j];
                if (player1.Network.IsQueuedForDespawn || player2.Network.IsQueuedForDespawn) continue;

                if (playersToDespawn?.Contains(player2) == true) continue;

                var pos1 = player1.GetWorldPosition();
                var pos2 = player2.GetWorldPosition();

                float radius1 = player1.GetCollisionRadius();
                float radius2 = player2.GetCollisionRadius();

                float distanceSquared = (pos1.X - pos2.X) * (pos1.X - pos2.X)
                                      + (pos1.Z - pos2.Z) * (pos1.Z - pos2.Z);
                float combinedRadius = radius1 + radius2;

                if (distanceSquared < combinedRadius)
                {
                    // Collision detected - bigger player eats smaller one
                    Player bigger, smaller;
                    if (player1.Score >= player2.Score)
                    {
                        bigger = player1;
                        smaller = player2;
                    }
                    else
                    {
                        bigger = player2;
                        smaller = player1;
                    }

                    // Add 50% of smaller's score to bigger
                    bigger.Score += smaller.Score / 2;

                    // Queue the smaller player for despawn
                    playersToDespawn ??= new List<Player>();
                    playersToDespawn.Add(smaller);
                }
            }
        }

        // Despawn players that have been eaten
        if (playersToDespawn != null)
        {
            foreach (var player in playersToDespawn)
            {
                player.Network.Despawn();
                Players.Remove(player);
            }
        }
    }
}
```

For a player who was just despawned, we want to send them back to the main menu, plus show them their final score.

`PlayerSpawner.cs` is already wired up to the UI. So, we'll add another method for it to handle when a player despawns:

```cs
    public void OnPlayerDespawn()
    {
        StartScreen.Visible = true;
        ScoreContainer.Visible = false;
    }
```

Then we need to call that method when the Player node actually despawns. To do this, we'll open `Player.cs` and add a `_Despwn` handler. Nebula automatically calls this method when the node is despawned from the server.

```cs
    public override void _Despawn()
    {
        base._Despawn();
        if (Network.IsClient && Network.IsCurrentOwner)
        {
            var manager = Network.CurrentWorld?.RootScene?.RawNode?.GetNode<PlayerSpawner>("PlayerSpawner");
            manager?.OnPlayerDespawn();
            var FinalScoreLabel = Network.CurrentWorld.RootScene.RawNode.GetNode<Label>("%FinalScoreLabel");
            FinalScoreLabel?.Text = $"Final Score: {Score}";

        }
    }
```

Since we're already in `Player.cs` and this chapter of the tutorial is quite short, we'll do one more little bonus thing: give each player cube a unique color!

There are a few different ways to do this. One easy way is to just save a "Seed" number for each Player. This seed will determinisitically choose a random color across clients:

```cs
    [NetProperty(NotifyOnChange = true)]
    public ulong ColorSeed { get; set; } = 0;
    protected virtual void OnNetChangeColorSeed(int tick, ulong oldValue, ulong newValue)
    {
        var random = new RandomNumberGenerator();
        random.Seed = ColorSeed;
        _model.GetActiveMaterial(0).Set("albedo_color", new Color(
            random.Randf(),
            random.Randf(),
            random.Randf()
            ));
    }
```

> [!NOTE]
> You will need to make sure the MeshInstance3D has a StandardMaterial3D attached for this to work.

![Demo](~/images/big-chungus/chapter-5/model-material.png)

That's literally it. Congratulations. You just finished Big Chungus Online!

![Demo](~/images/big-chungus/chapter-1/completed-game.gif)

## Conclusion

Nebula is a free, open-source project. Its development is aided by awesome people like you. Thank you for giving it a try.

If you encounter any issues along the way, or have any questions, please feel free to share and ask. We would also love to hear about your experience using Nebula, as well as any feature requests you have.

You can add tickets or code changes in Github: https://github.com/Heavenlode/Nebula

You can join the new Nebula discord community: https://discord.gg/AUjzVA4sEK

Look forward to hearing from you soon :)